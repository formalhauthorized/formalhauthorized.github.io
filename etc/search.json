



{"search" : [
  {
    "url" : "/sections/etc/posts/games/snake-game/",
    "title" : "Snake game",
    "text" : "snake game undefined ai generated snake wrapper { display: flex; flex direction: column; align items: center; margin: 2rem 0; font family: sans serif; color: var( text color #222); } snake canvas border: 1px solid var( border color #ccc); background: var( bg color #fafafa); } snake ui 05rem 0 font size: 12rem; } snake instructions 09rem; margin top: 05rem; var( subtle color #555); } score: 0 use arrow keys wasd move space restart (() =&gt; const cvs = documentgetelementbyid(&#39;snake canvas&#39;); ctx cvsgetcontext(&#39;2d&#39;); ui documentgetelementbyid(&#39;snake score&#39;); box 20; // size one cell (px) w cvswidth / box; h cvsheight box; let snake dir food score speed tick running; randpos () ({ x: mathfloor(mathrandom() * w) y: h) }); spawnfood { food randpos(); } while (snakesome(p px === foodx &amp;&amp; py foody)); }; reset [{ mathfloor(w 2) mathfloor(h 2) }]; dir 1 }; score speed 120; ms per step tick running true; uitextcontent &#39;score: 0&#39;; spawnfood(); gameover false; ctxfillstyle &#39;rgba(000 5)&#39;; ctxfillrect(0 0 cvswidth cvsheight); &#39;#fff&#39;; ctxtextalign &#39;center&#39;; ctxfont &#39;20px sans serif&#39;; ctxfilltext(&#39;game over&#39; 2 2); ctxfilltext(&#39;press space&#39; 2 + 24); draw ctxclearrect(0 cvsheight); snake &#39;#0c0&#39;; snakeforeach(({ x y }) ctxfillrect(x box box)); food &#39;#d00&#39;; ctxfillrect(foodx foody box); update (!running) return; head snake[0] x dirx snake[0] y diry wall collision (headx || heady h) return gameover(); self headx heady)) snakeunshift(head); foody) score++; &#39; score; (score % 5 0) mathmax(40 8); } else snakepop(); loop (++tick update(); draw(); settimeout(loop windowaddeventlistener(&#39;keydown&#39; e (!running ecode &#39;space&#39;) reset(); return; return; switch (ecode) case &#39;arrowup&#39;: &#39;keyw&#39;: (diry 1 }; break; &#39;arrowdown&#39;: &#39;keys&#39;: 1 &#39;arrowleft&#39;: &#39;keya&#39;: (dirx 1 &#39;arrowright&#39;: &#39;keyd&#39;: reset(); loop(); })(); #app #game #ai",
    "description" : ""
  },
  {
    "url" : "/sections/etc/posts/games/tetris-game/",
    "title" : "Tetris game",
    "text" : "tetris game undefined ai generated tetris wrapper{ display:flex; gap:1rem; justify content:center; align items:flex start; flex wrap:wrap; font family:sans serif; color:var( tetris text #222); background:var( tetris bg #fafafa); padding:1rem; border:1px solid var( tetris border #ccc); border radius:4px; } tetris canvas{border:2px #333;background:#000;} tetris side{width:120px;font size: 9rem} tetris side h3{margin: 3rem 0;font size:1rem} tetris next canvas{background:#000;border:1px #222;margin bottom: 5rem} tetris controls{font size: 75rem;margin top: 5rem;color:#555} score 0 level lines next ← → move ↓ soft drop ↑ rotate space hard c hold (()=&gt;{ /* config */ const cols=10 rows=20 size=30; // board = 300×600 colors=[ null &#39;#ff0d72&#39; &#39;#0dc2ff&#39; &#39;#0dff72&#39; &#39;#f538ff&#39; &#39;#ff8e0d&#39; &#39;#ffe138&#39; &#39;#3877ff&#39; ]; shapes=[ [[0000] [1111] [0000] [0000]] [[11] [11]] o [[010] [111] [000]] t [[011] [110] [000]] s [[110] [011] [000]] z [[100] [111] [000]] j [[001] [111] [000]] l ]; canvas setup cvs=documentgetelementbyid(&#39;tetris board&#39;); ctx=cvsgetcontext(&#39;2d&#39;); nxt=documentgetelementbyid(&#39;tetris next&#39;); nctx=nxtgetcontext(&#39;2d&#39;); ctxscale(sizesize); nctxscale(sizesize); state let board=arrayfrom({length:rows} ()=&gt;array(cols) fill(0)); piece next hold canhold=true; score=0 lines=0 level=0; dropinterval lasttime=0; helpers createpiece=()=&gt;mathfloor(mathrandom()*7)+1; drawsquare=(xycolorctx)=&gt;{ctxfillstyle=color;ctxfillrect(xy11);}; drawmatrix=(matoffsetctx)=&gt;{ matforeach((rowy)=&gt;rowforeach((valx)=&gt;{ (val){drawsquare(x+offsetxy+offsetycolors[val] ctx);} })); }; rotate=(matrix)=&gt;{ n=matrixlength; rotated=matrixmap((_)=&gt;matrixmap(row=&gt;row[]) reverse()); return rotated; collide=(posmat)=&gt;{ (let y=0;y&lt;matlength;++y){ x=0;x&lt;mat[y] length;++x){ (mat[y][x]&amp;&amp; (board[y+posy]===undefined|| board[y+posy][x+posx]===undefined|| board[y+posy][x+posx])) true; } false; merge=()=&gt;{ pieceshapeforeach((rowy)=&gt;rowforeach((valx)=&gt;{ (val) board[y+piecey][x+piecex]=val; clearlines=()=&gt;{ outer:(let y=rows 1;y&gt;=0; y){ (board[y] every(v=&gt;v)){ boardsplice(y1); boardunshift(array(cols) fill(0)); ++lines; score+=(level+1)*100; ++y; check same line again level=mathfloor(lines/10); resetpiece=()=&gt;{ piece={shape:shapes[next] x:mathfloor(cols/2) 1y:0kind:next}; next=createpiece(); (collide(piecepieceshape)){gameover();return;} drawnext(); score+=4; bonus drawnext=()=&gt;{ nctxclearrect(0044); drawmatrix(shapes[next] {x:1y:1} nctx); draw=()=&gt;{ ctxclearrect(00colsrows); drawmatrix(board {x:0y:0} ctx); (piece){ ghost ghost={ piece}; while(!collide({ ghosty:ghosty+1} ghostshape)) ++ghosty; ghostshapeforeach((rowy)=&gt;rowforeach((valx)=&gt;{ drawsquare(x+ghostxy+ghosty &#39;rgba(255255255 2)&#39; ctx); drawmatrix(pieceshapepiecectx); controls documentaddeventlistener(&#39;keydown&#39; e=&gt;{ (!piece) return; (ecode===&#39;arrowleft&#39; &amp;&amp; !collide({ piecex:piecex 1} pieceshape)) piecex ; else (ecode===&#39;arrowright&#39; !collide({ piecex:piecex+1} pieceshape)) piecex++; (ecode===&#39;arrowdown&#39; !collide({ piecey:piecey+1} pieceshape)){piecey++;score+=1;} (ecode===&#39;arrowup&#39;){ rotated=rotate(pieceshape); (!collide(piecerotated)) pieceshape=rotated; }else (ecode===&#39;space&#39;){ while(!collide({ piecey:piecey+1} pieceshape)){piecey++;score+=2;} playerdrop(); (ecode===&#39;keyc&#39; canhold){ [holdpiecekind]=[piecekindhold||createpiece()]; pieceshape=shapes[piecekind]; piecex=mathfloor(cols/2) 1; piecey=0; canhold=false; }); playerdrop=()=&gt;{ (!collide({ piecey:piecey+1} pieceshape)) piecey++; else{ merge(); clearlines(); resetpiece(); draw(); updatescore(); updatescore=()=&gt;{ documentgetelementbyid(&#39;tetris score&#39;) textcontent=score; documentgetelementbyid(&#39;tetris level&#39;) textcontent=level; documentgetelementbyid(&#39;tetris lines&#39;) textcontent=lines; gameover=()=&gt;{ clearinterval(dropinterval); ctxfillstyle=&#39;rgba(000 6)&#39;; ctxfillrect(00colsrows); ctxfillstyle=&#39;#fff&#39;; ctxtextalign=&#39;center&#39;; ctxfont=&#39;12px sans serif&#39;; ctxfilltext(&#39;game over&#39; cols/2rows/2); ctxfilltext(&#39;press r restart&#39; cols/2rows/2+15); start=()=&gt;{ next=createpiece(); score=lines=level=0; dropinterval=setinterval(playerdrop1000/((level+1)* 5+1)); ((ecode===&#39;keyr&#39; || ecode===&#39;space&#39;) !dropinterval) start(); start(); })(); #app #game #ai",
    "description" : ""
  }]}
